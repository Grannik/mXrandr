#!/bin/bash
source "sXrandr.sh"
# это цвет текста списка перед курсором при значении 0 в переменной  UNMARK(){ $e "\e[0m";}
 UNMARK(){ $e "\e[0m";}
 MARK(){ $e "\e[1;37m";}
#
 HEAD()
{
 for (( a=2; a<=39; a++ ))
  do
   TPUT $a 1
    $E "$na";
  done
   TPUT  1 1;$E "$nb";UNMARK;
   TPUT  2 3;$E "\e[36m RandR version 1.2 options\e[0m\e[2m    Варианты RandR версии 1.2 Эти параметры доступны\e[0m";
   TPUT  3 3;$E "\e[2m только для X-сервера, поддерживающего RandR версии 1.2 или новее.\e[0m";
   TPUT  4 1;$E "$nc";
   TPUT 14 3;$E "\e[36mPer-output options\e[0m                             \e[2m Параметры для каждого выхода\e[0m";
   TPUT 29 3;$E "\e[36mRandR version 1.1 options\e[0m                         \e[2m Варианты RandR версии 1.1\e[0m";
   TPUT 30 2;$E "\e[2m Параметры доступны для X-серверов, поддерживающих RandR 1.1 и старше. Они\e[0m";
   TPUT 31 2;$E "\e[2m по-прежнему действительны для более новых X-серверов, но они не взаимодейст-\e[0m";
   TPUT 32 2;$E "\e[2m вуют разумным образом с параметрами версии 1.2 в той же командной строке.\e[0m";

   TPUT 38 1;$E "$nd";
}
 FOOT(){ MARK;TPUT 40 1;$E "$ne";UNMARK;}
#
  M0(){ TPUT  5 3; $e "Заставляет xrandr отображать содержимое свойств         \e[32m --prop --properties \e[0m";}
  M1(){ TPUT  6 3; $e "Изменяет конфигурацию экрана до указанного размера        \e[32m --fb widthxheight \e[0m";}
  M2(){ TPUT  7 3; $e "Устанавливает значение, как физический размер экрана X  \e[32m --fbmm widthxheight \e[0m";}
  M3(){ TPUT  8 3; $e "Устанавливает DPI, количество точек на дюйм                           \e[32m --dpi \e[0m";}
  M4(){ TPUT  9 3; $e "Устанавливает значение, как физический размер экрана X    \e[32m --dpi from-output \e[0m";}
  M5(){ TPUT 10 3; $e "Cоздаёт новый режим отображения по размеру и частоте    \e[32m --newmode name mode \e[0m";}
  M6(){ TPUT 11 3; $e "Это удаляет режим с сервера                                   \e[32m --rmmode name \e[0m";}
  M7(){ TPUT 12 3; $e "Добавьте режим в набор допустимых режимов для вывода  \e[32m --addmode output name \e[0m";}
  M8(){ TPUT 13 3; $e "Удалить режим из набора допустимых режимов для вывода \e[32m --delmode output name \e[0m";}
#
  M9(){ TPUT 15 3; $e "Выбирает выход для перенастройки                            \e[32m --output output \e[0m";}
 M10(){ TPUT 16 3; $e "Для подключенных, но отключенных выходов                             \e[32m --auto \e[0m";}
 M11(){ TPUT 17 3; $e "Aктивирует указанный режим                                           \e[32m --mode \e[0m";}
 M12(){ TPUT 18 3; $e "Это выбирает тот же режим, что и --auto                         \e[32m --preferred \e[0m";}
 M13(){ TPUT 19 3; $e "Расположите вывод на экране, используя координаты пикселей        \e[32m --pos xxy \e[0m";}
 M14(){ TPUT 20 3; $e "Устанавливает частоту обновления                                     \e[32m --rate \e[0m";}
 M15(){ TPUT 21 3; $e "Отражение может быть одним из                          \e[32m --reflect reflection \e[0m";}
 M16(){ TPUT 22 3; $e "Поворот может быть одним из                               \e[32m --rotate rotation \e[0m";}
 M17(){ TPUT 23 3; $e "              \e[32m --left-of --right-of --above --below --same-as another-output \e[0m";}
 M18(){ TPUT 24 3; $e "Задает выходное свойство                               \e[32m --set property value \e[0m";}
 M19(){ TPUT 25 3; $e "Отключает экран                                                       \e[32m --off \e[0m";}
 M20(){ TPUT 26 3; $e "Использует указанный crtc                                       \e[32m --crtc crtc \e[0m";}
 M21(){ TPUT 27 3; $e "позволяет установить коррекцию гаммы в формате     \e[32m --gamma [red:green:blue] \e[0m";}
 M22(){ TPUT 28 3; $e "Умножьте значения гаммы на crtc                     \e[32m --brightness brightness \e[0m";}
#
 M23(){ TPUT 33 3; $e "Это устанавливает размер экрана    \e[32m -s --size size-index --size widthxheight \e[0m";}
 M24(){ TPUT 34 3; $e "Это устанавливает частоту обновления               \e[32m -r --rate --refresh rate \e[0m";}
 M25(){ TPUT 35 3; $e "Это определяет ориентацию экрана                  \e[32m -o --orientation rotation \e[0m";}
 M26(){ TPUT 36 3; $e "Отражение по оси X                                                       \e[32m -x \e[0m";}
 M27(){ TPUT 37 3; $e "Отражение по оси Y                                                       \e[32m -y \e[0m";}
#
 M28(){ TPUT 39 3; $e "Exit                                                                         ";}
LM=28
   MENU(){ for each in $(seq 0 $LM);do M${each};done;}
    POS(){ if [[ $cur == up ]];then ((i--));fi
           if [[ $cur == dn ]];then ((i++));fi
           if [[ $i -lt 0   ]];then i=$LM;fi
           if [[ $i -gt $LM ]];then i=0;fi;}
REFRESH(){ after=$((i+1)); before=$((i-1))
           if [[ $before -lt 0  ]];then before=$LM;fi
           if [[ $after -gt $LM ]];then after=0;fi
           if [[ $j -lt $i      ]];then UNMARK;M$before;else UNMARK;M$after;fi
           if [[ $after -eq 0 ]] || [ $before -eq $LM ];then
           UNMARK; M$before; M$after;fi;j=$i;UNMARK;M$before;M$after;}
   INIT(){ R;HEAD;FOOT;MENU;}
     SC(){ REFRESH;MARK;$S;$b;cur=`ARROW`;}
# Функция возвращения в меню
     ES(){ MARK;$e " ENTER = main menu ";$b;read;INIT;};INIT
  while [[ "$O" != " " ]]; do case $i in
  0) S=M0;SC; if [[ $cur == enter ]];then R;echo -e "
 Этот параметр заставляет xrandr отображать содержимое свойств для каждого вывода.
\e[32m --verbose\e[0m также включает\e[32m --prop\e[0m
";ES;fi;;
  1) S=M1;SC; if [[ $cur == enter ]];then R;echo -e "
 Изменяет конфигурацию экрана до указанного размера.
 Все сконфигурированные мониторы должны соответствовать этому размеру.
 Если этот параметр не указан, xrandr вычисляет наименьший размер экрана,
 который будет содержать набор настроенных выходных данных;
 эта опция позволяет переопределить это поведение.
";ES;fi;;
  2) S=M2;SC; if [[ $cur == enter ]];then R;echo -e "
 Устанавливает значение, сообщаемое как физический размер экрана X
 в целом (объединение всех настроенных мониторов).
 В конфигурациях с несколькими мониторами с разными DPI это значение не имеет
 физического смысла, но может использоваться некоторыми устаревшими клиентами,
 которые не поддерживают RandR версии 1.2,
 для вычисления эталонного масштабирования шрифта.
 Обычно xrandr сбрасывает сообщаемые значения физического размера,
 чтобы поддерживать постоянное значение DPI.
 Это отменяет это вычисление. Значение DPI по умолчанию — 96.
";ES;fi;;
  3) S=M3;SC; if [[ $cur == enter ]];then R;echo -e "
 устанавливает DPI, количество точек на дюйм,
 которое позволяет вычислить правильный размер для окон;
\e[32m --dpi\e[0m
";ES;fi;;
  4) S=M4;SC; if [[ $cur == enter ]];then R;echo -e "
 Это также устанавливает значение, сообщаемое как физический размер экрана X в целом
 (объединение всех настроенных мониторов). В конфигурациях с несколькими мониторами
 с разными DPI это значение не имеет физического смысла, но может использоваться
 некоторыми устаревшими клиентами, которые не поддерживают RandR версии 1.2,
 для вычисления эталонного масштабирования шрифта.
 Этот параметр использует либо указанное значение DPI, либо DPI данного вывода для
 вычисления соответствующего физического размера с использованием любого
 установленного размера пикселя.
 Типичными значениями являются значения по умолчанию (96 DPI),
 DPI единственного монитора в конфигурациях с одним монитором
 или DPI основного монитора в конфигурациях с несколькими мониторами.
";ES;fi;;
  5) S=M5;SC; if [[ $cur == enter ]];then R;echo -e "
 Новые модели могут быть добавлены на сервер, а затем связаны с выходными данными.
 Этот вариант делает первый. Режим указывается с помощью синтаксиса
 ModeLine для xorg.conf:
\e[32m clock hdisp hsyncstart hsyncend htotal vdisp vsyncstart vsyncend vtotal flags\e[0m
 флаги могут состоять из нуля или более из:
\e[32m +HSync, -HSync, +VSync, -VSync, Interlace, DoubleScan, CSync, +CSync, -CSync.\e[0m
 Несколько инструментов позволяют вычислить обычную модельную линию по высоте,
 ширине и частоте обновления, например, вы можете использовать cvt.
";ES;fi;;
  6) S=M6;SC; if [[ $cur == enter ]];then R;echo -e "
 Это удаляет режим с сервера, если он в противном случае не используется.
";ES;fi;;
  7) S=M7;SC; if [[ $cur == enter ]];then R;echo -e "
 Добавьте режим в набор допустимых режимов для вывода.
";ES;fi;;
  8) S=M8;SC; if [[ $cur == enter ]];then R;echo -e "
 Удалить режим из набора допустимых режимов для вывода.
";ES;fi;;
  9) S=M9;SC; if [[ $cur == enter ]];then R;echo -e "
 Выбирает выход для перенастройки. Используйте либо имя вывода, либо XID.
";ES;fi;;
 10) S=M10;SC;if [[ $cur == enter ]];then R;echo -e "
 Для подключенных, но отключенных выходов это позволит использовать их первый
 предпочтительный режим (или что-то близкое к 96 dpi,
 если у них нет предпочтительного режима).
 Для отключенных, но включенных выходов это отключит их.
";ES;fi;;
 11) S=M11;SC;if [[ $cur == enter ]];then R;echo -e "
 Это выбирает режим. Используйте либо имя, либо XID для режима. Чтобы изменить
 разрешение экрана Linux на одно из доступных,
 используйте опцию --mode вместе с --output:
\e[32m xrandr --output HDMI-1 --mode 1680x1050\e[0m
 Теперь звёздочка выводится около разрешения 1680х1050.
";ES;fi;;
 12) S=M12;SC;if [[ $cur == enter ]];then R;echo -e "
 Это выбирает тот же режим, что и --auto,
 но автоматически не включает и не отключает вывод.
";ES;fi;;
 13) S=M13;SC;if [[ $cur == enter ]];then R;echo -e "
 Расположите вывод на экране, используя координаты пикселей.
 В случае применения отражения или вращения перевод применяется после эффектов.
";ES;fi;;
 14) S=M14;SC;if [[ $cur == enter ]];then R;echo -e "
 Это отмечает предпочтение частоты обновления, близкой к указанному значению,
 когда несколько режимов имеют одно и то же имя,
 будет выбран тот, у которого ближайшая частота обновления.
";ES;fi;;
 15) S=M15;SC;if [[ $cur == enter ]];then R;echo -e "
 Отражение может быть одним из\e[32m 'normal' 'x', 'y'\e[0m or\e[32m 'xy'\e[0m
 Это заставляет выходное содержимое отражаться по указанным осям.
";ES;fi;;
 16) S=M16;SC;if [[ $cur == enter ]];then R;echo -e "
 Поворот может быть одним из\e[32m 'normal', 'left', 'right'\e[0m or \e[32m'inverted'\e[0m
 Это приводит к тому, что содержимое вывода поворачивается в указанном направлении.
\e[32m 'right'\e[0m указывает вращение изображения по часовой стрелке,
 а\e[32m 'left'\e[0m — против часовой стрелки.";ES;fi;;
 17) S=M17;SC;if [[ $cur == enter ]];then R;echo -e "
\e[32m --left-of --right-of --above --below --same-as another-output\e[0m
 Используйте один из этих параметров, чтобы расположить вывод относительно положения
 другого вывода. Это позволяет удобно размещать выходные данные на экране.
 Позиция всегда вычисляется относительно новой позиции другого вывода,
 поэтому нельзя говорить\e[32m --output a --left-of b --output b --left-of a\e[0m
";ES;fi;;
 18) S=M18;SC;if [[ $cur == enter ]];then R;echo -e "
 Задает выходное свойство.
 Целочисленные свойства могут быть указаны как действительный (см. --prop) список
 разделенных запятыми десятичных или шестнадцатеричных (с ведущим 0x) значений.
 Свойства атома могут быть установлены на любой из допустимых атомов (см. --prop).
 Строковые свойства могут быть установлены на любое значение.
";ES;fi;;
 19) S=M19;SC;if [[ $cur == enter ]];then R;echo -e "
 Отключает вывод.
";ES;fi;;
 20) S=M20;SC;if [[ $cur == enter ]];then R;echo -e "
 Использует указанный crtc (либо как индекс в списке CRTC, либо как XID).
 При обычном использовании этот параметр не требуется, поскольку xrandr пытается
 сделать разумный выбор, какой crtc использовать для каждого вывода. Если по
 какой-то причине это не удается, этот параметр может переопределить обычный выбор.
";ES;fi;;
 21) S=M21;SC;if [[ $cur == enter ]];then R;echo -e "
 Установите указанные значения с плавающей запятой в качестве гамма-коррекции на
 crtc, в настоящее время подключенном к этому выходу.
 Если зеленый и синий не указаны, для всех трех компонентов будет использоваться
 красное значение.
 Обратите внимание, что вы не можете получить два разных значения для
 клонированных выходных данных (т. е. тех, которые используют один и тот же crtc)
 и что переключение вывода на другой crtc вообще не меняет гамма-коррекции crtc.
";ES;fi;;
 22) S=M22;SC;if [[ $cur == enter ]];then R;echo -e "
 Умножьте значения гаммы на crtc, в настоящее время подключенном к выходу,
 на указанное плавающее значение. Полезно для слишком ярких или слишком тусклых
 выходных сигналов. Тем не менее, это только программная модификация, если ваше
 оборудование поддерживает фактическое изменение яркости, вы, вероятно,
 предпочтете использовать xbacklight.
";ES;fi;;
 23) S=M23;SC;if [[ $cur == enter ]];then R;echo -e "
 Это устанавливает размер экрана, либо совпадая по размеру,
 либо используя индекс в списке доступных размеров.
";ES;fi;;
 24) S=M24;SC;if [[ $cur == enter ]];then R;echo -e "
 Это устанавливает частоту обновления, ближайшую к указанному значению.
";ES;fi;;
 25) S=M25;SC;if [[ $cur == enter ]];then R;echo -e "
 Это определяет ориентацию экрана
 и может быть нормальной, перевернутой, левой или правой.
";ES;fi;;
 26) S=M26;SC;if [[ $cur == enter ]];then R;echo -e "
 Отражение по оси X.
";ES;fi;;
 27) S=M27;SC;if [[ $cur == enter ]];then R;echo -e "
  Отражение по оси Y.
";ES;fi;;
#
 28) S=M28;SC;if [[ $cur == enter ]];then R;exit 0;fi;;
 esac;POS;done
