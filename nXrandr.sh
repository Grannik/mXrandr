#!/bin/bash
source "sXrandr.sh"
# это цвет текста списка перед курсором при значении 0 в переменной  UNMARK(){ $e "\e[0m";}
 UNMARK(){ $e "\e[0m";}
 MARK(){ $e "\e[1;37m";}
#
 HEAD()
{
 for (( a=2; a<=39; a++ ))
  do
   TPUT $a 1
    $E "$na";
  done
 TPUT  1 1;$E "$nb";UNMARK;
 TPUT  2 3;$E "\e[36mOptions\e[0m                                                                \e[2mОпции\e[0m";
 TPUT  3 1;$E "$nc";
 TPUT 14 1;$E "$nc";
 TPUT 15 3;$E "\e[36mRandR version 1.5 options\e[0m";
 TPUT 16 3;$E "\e[2mОпции для RandR 1.5 используются как надмножество опций для RandR 1.4.\e[0m";
 TPUT 23 1;$E "$nc";
 TPUT 24 3;$E "\e[36mRandR version 1.3 options\e[0m";
 TPUT 25 3;$E "\e[2mОпции для RandR 1.3 используются как надмножество опций для RandR 1.2.\e[0m";
 TPUT 29 1;$E "$nc";
 TPUT 30 3;$E "\e[36mPer-output options\e[0m";
 TPUT 31 3;$E "\e[2mПараметры для каждого выхода\e[0m";
 TPUT 38 1;$E "$nd";
}
 FOOT(){ MARK;TPUT 40 1;$E "$ne";UNMARK;}
#
  M0(){ TPUT  4 3; $e "Распечатайте сводку об использовании и выйдите                       \e[32m --help \e[0m";}
  M1(){ TPUT  5 3; $e "Распечатайте версию RandR, сообщенную X-сервером, и выйдите    \e[32m -v --version \e[0m";}
  M2(){ TPUT  6 3; $e "Делает xrandr более подробным                                     \e[32m --verbose \e[0m";}
  M3(){ TPUT  7 3; $e "Выводится текущая конфигурация                                   \e[32m -q --query \e[0m";}
  M4(){ TPUT  8 3; $e "Выполняет все указанные действия...                                \e[32m --dryrun \e[0m";}
  M5(){ TPUT  9 3; $e "Примените модификации, не захватывая экран                         \e[32m --nograb \e[0m";}
  M6(){ TPUT 10 3; $e "Эта опция выбирает используемый дисплей X                 \e[32m -d --display name \e[0m";}
  M7(){ TPUT 11 3; $e "устанавливает дисплей для настройки по ID                  \e[32m -s --screen snum \e[0m";}
  M8(){ TPUT 12 3; $e "Принудительно использует протокол RandR версии 1.1                     \e[32m --q1 \e[0m";}
  M9(){ TPUT 13 3; $e "Принудительно использует протокол RandR версии 1.2                    \e[32m --q12 \e[0m";}
#
 M10(){ TPUT 17 3; $e "Отчетная информация обо всех определенных мониторах          \e[32m --listmonitors \e[0m";}
 M11(){ TPUT 18 3; $e "Сообщать информацию об активных мониторах              \e[32m --listactivemonitors \e[0m";}
 M12(){ TPUT 19 3; $e "Определите новый монитор                 \e[32m --setmonitor name geometry outputs \e[0m";}
 M13(){ TPUT 20 3; $e "Удалить данный пользовательский монитор                   \e[32m --delmonitor name \e[0m";}
 M14(){ TPUT 21 3; $e "Установите источник               \e[32m --setprovideroutputsource provider source \e[0m";}
 M15(){ TPUT 22 3; $e "Установите провайдера                \e[32m --setprovideroffloadsink provider sink \e[0m";}
#
 M16(){ TPUT 26 3; $e "Сообщить информацию о доступных провайдерах                 \e[32m --listproviders \e[0m";}
 M17(){ TPUT 27 3; $e "Вернуть текущую конфигурацию экрана                               \e[32m --current \e[0m";}
 M18(){ TPUT 28 3; $e "Не определяйте основной выход                                   \e[32m --noprimary \e[0m";}
#
 M19(){ TPUT 32 3; $e "Эта опция устанавливает параметры панорамирования    \e[32m --panning widthxheight \e[0m";}
 M20(){ TPUT 33 3; $e "Задает матрицу преобразования для применения к выходным данным  \e[32m --transform \e[0m";}
 M21(){ TPUT 34 3; $e "Выбирает метод масштабирующего фильтра                  \e[32m --filter filtermode \e[0m";}
 M22(){ TPUT 35 3; $e "Изменяет размеры выходного изображения                        \e[32m --scale x[xy] \e[0m";}
 M23(){ TPUT 36 3; $e "Задает размер в пикселях области кадрового буфера          \e[32m --scale-from wxh \e[0m";}
 M24(){ TPUT 37 3; $e "Выбрать основной экран                                            \e[32m --primary \e[0m";}
#
 M25(){ TPUT 39 3; $e " Exit                                                                        ";}
LM=25
   MENU(){ for each in $(seq 0 $LM);do M${each};done;}
    POS(){ if [[ $cur == up ]];then ((i--));fi
           if [[ $cur == dn ]];then ((i++));fi
           if [[ $i -lt 0   ]];then i=$LM;fi
           if [[ $i -gt $LM ]];then i=0;fi;}
REFRESH(){ after=$((i+1)); before=$((i-1))
           if [[ $before -lt 0  ]];then before=$LM;fi
           if [[ $after -gt $LM ]];then after=0;fi
           if [[ $j -lt $i      ]];then UNMARK;M$before;else UNMARK;M$after;fi
           if [[ $after -eq 0 ]] || [ $before -eq $LM ];then
           UNMARK; M$before; M$after;fi;j=$i;UNMARK;M$before;M$after;}
   INIT(){ R;HEAD;FOOT;MENU;}
     SC(){ REFRESH;MARK;$S;$b;cur=`ARROW`;}
# Функция возвращения в меню
     ES(){ MARK;$e " ENTER = main menu ";$b;read;INIT;};INIT
  while [[ "$O" != " " ]]; do case $i in
  0) S=M0;SC; if [[ $cur == enter ]];then R;echo -e "
\e[32m xrandr --help\e[0m
";ES;fi;;
  1) S=M1;SC; if [[ $cur == enter ]];then R;echo -e "
 Распечатайте версию RandR, сообщенную X-сервером, и выйдите:
\e[32m xrandr -v\e[0m
#
\e[32m xrandr --version\e[0m
";ES;fi;;
  2) S=M2;SC; if [[ $cur == enter ]];then R;echo -e "
 Делает xrandr более подробным. При использовании с -q (или без других параметров)
 xrandr будет отображать больше информации о состоянии сервера. Обратите внимание,
 что информация о гамме и яркости является лишь приблизительным значением полного
 цветового профиля, хранящегося на сервере.
 При использовании вместе с параметрами, которые перенастраивают систему,
 будет сообщаться о ходе выполнения изменений конфигурации.
\e[32m xrandr --verbose \e[0m";ES;fi;;
  3) S=M3;SC; if [[ $cur == enter ]];then R;echo -e "
 Когда эта опция присутствует или когда изменения конфигурации не запрашиваются,
 xrandr отображает текущее состояние системы.
\e[32m xrandr -q\e[0m
\e[32m xrandr --query\e[0m
";ES;fi;;
  4) S=M4;SC; if [[ $cur == enter ]];then R;echo -e "
 Выполняет все указанные действия, за исключением того, что изменения не вносятся.
\e[32m xrandr --dryrun\e[0m
";ES;fi;;
  5) S=M5;SC; if [[ $cur == enter ]];then R;echo -e "
 Примените модификации, не захватывая экран.
 Это позволяет избежать блокировки других приложений во время обновления,
 но также может привести к тому, что некоторые приложения,
 обнаруживающие изменение размера экрана, получат старые значения.
";ES;fi;;
  6) S=M6;SC; if [[ $cur == enter ]];then R;echo -e "
 Эта опция выбирает используемый дисплей X.
 Обратите внимание, что это относится к абстракции экрана X,
 а не к монитору (или выходу).
";ES;fi;;
  7) S=M7;SC; if [[ $cur == enter ]];then R;echo -e "
 Эта опция выбирает, каким экраном управлять.
 Обратите внимание, что это относится к абстракции экрана X,
 а не к монитору (или выходу).
";ES;fi;;
  8) S=M8;SC; if [[ $cur == enter ]];then R;echo -e "
 Принудительно использует протокол RandR версии 1.1,
 даже если доступна более поздняя версия.
";ES;fi;;
  9) S=M9;SC; if [[ $cur == enter ]];then R;echo -e "
 Принудительно использует протокол RandR версии 1.2,
 даже если дисплей не сообщает, что он поддерживается
 или доступна более поздняя версия.
";ES;fi;;
 10) S=M10;SC;if [[ $cur == enter ]];then R;echo -e "
 Отчетная информация обо всех определенных мониторах.
";ES;fi;;
 11) S=M11;SC;if [[ $cur == enter ]];then R;echo -e "
 Сообщать информацию об активных в данный момент мониторах.
";ES;fi;;
 12) S=M12;SC;if [[ $cur == enter ]];then R;echo -e "
 Определите новый монитор с заданной геометрией и связанный с заданными выходами.
 Выходной список представляет собой либо ключевое слово none, либо список
 выходных данных, разделенных запятыми.
 Геометрия — это либо ключевое слово auto, и в этом случае монитор будет
 автоматически отслеживать геометрию связанных выходов, либо указание вручную
 в форме w/mmwxh/mmh+x+y, где w, h, x, y указаны в пикселях.
 а mmw, mmh — физические размеры монитора.
";ES;fi;;
 13) S=M13;SC;if [[ $cur == enter ]];then R;echo -e "
 Удалить данный пользовательский монитор.
";ES;fi;;
 14) S=M14;SC;if [[ $cur == enter ]];then R;echo -e "
 Установите источник в качестве источника отображаемых выходных изображений для
 провайдера. Это возможно только в том случае, если источник и поставщик имеют
 возможности вывода источника и вывода приемника соответственно. Если источник
 равен 0x0, то провайдер отключается от своего текущего источника вывода.
";ES;fi;;
 15) S=M15;SC;if [[ $cur == enter ]];then R;echo -e "
 Установите провайдера в качестве устройства разгрузки рендеринга для приемника.
 Это возможно только в том случае, если у провайдера и приемника есть возможности
 разгрузки источника и разгрузки приемника соответственно. Если приемник равен 0x0,
 то провайдер отключается от своего текущего приемника разгрузки рендеринга.
";ES;fi;;
 16) S=M16;SC;if [[ $cur == enter ]];then R;echo -e "
 Сообщить информацию о доступных провайдерах.
";ES;fi;;
 17) S=M17;SC;if [[ $cur == enter ]];then R;echo -e "
 Вернуть текущую конфигурацию экрана без опроса изменений оборудования.
";ES;fi;;
 18) S=M18;SC;if [[ $cur == enter ]];then R;echo -e "
 Не определяйте основной выход.
";ES;fi;;
 19) S=M19;SC;if [[ $cur == enter ]];then R;echo -e "
\e[32m --panning widthxheight[+x+y[/track_widthxtrack_height+track_x+track_y[/border_left
 /border_top/border_right/border_bottom]]]\e[0m
 Эта опция устанавливает параметры панорамирования.
 Как только панорамирование включено, положение CRTC может меняться при каждом
 перемещении указателя.
 Первые четыре параметра определяют общую область панорамирования,
 следующие четыре — область отслеживания указателя
 (которая по умолчанию равна той же области).
 Последние четыре параметра определяют границу и по умолчанию равны 0.
 Нулевая ширина или высота отключает панорамирование по соответствующей оси.
 Обычно вам нужно одновременно устанавливать размер экрана с --fb
";ES;fi;;
 20) S=M20;SC;if [[ $cur == enter ]];then R;echo -e "
\e[32m --transform a,b,c,d,e,f,g,h,i\e[0m

 Задает матрицу преобразования для применения к выходным данным.
 Билинейный фильтр выбирается автоматически, если также не указан
 параметр --filter. Математическая форма соответствует:
\e[32m a b c
 d e f
 g h i\e[0m

 Преобразование основано на однородных координатах.
 Матрица, умноженная на вектор координат пикселя вывода,
 дает преобразованный вектор координат пикселя в графическом буфере.
 Точнее, вектор (x y) выходного пикселя расширяется до 3 значений (x y w),
 где 1 является координатой w, и умножается на матрицу.
 Конечные координаты устройства пикселя затем вычисляются с помощью так называемого
 гомогенного деления на преобразованную координату w.
 Другими словами, координаты устройства (x' y') преобразованного пикселя:
\e[32m
 x' = (ax + by + c) / w' \e[0m and\e[32m
 y' = (dx + ey + f) / w'   ,
 with  w' = (gx + hy + i)  .
\e[0m
 Как правило, a и e соответствуют масштабированию по осям X и Y, c и f соответст-
 вуют перемещению по этим осям, а g, h и i равны соответственно 0, 0 и 1.
 Матрица также может использоваться для выражения более сложные преобразования,
 такие как коррекция трапецеидальных искажений или вращение.
 Для поворота на угол T можно использовать эту формулу:
\e[32m
 cos T -sin T 0
 sin T  cos T 0
     0      0 1
\e[0m
 В качестве специального аргумента вместо передачи матрицы можно передать строку
 none, в этом случае используются значения по умолчанию
 (единичная матрица без фильтра).
";ES;fi;;
 21) S=M21;SC;if [[ $cur == enter ]];then R;echo -e "
 Выбирает метод масштабирующего фильтра, который будет применяться
 при масштабировании или преобразовании экрана.
 Может быть либо 'bilinear', либо 'nearest'.
";ES;fi;;
 22) S=M22;SC;if [[ $cur == enter ]];then R;echo -e "
 Изменяет размеры выходного изображения.
 Если значение y опущено, значение x будет использоваться для обоих измерений.
 Значения больше 1 приводят к сжатию экрана
 (размер экрана больше, чем размер режима вывода),
 а значения меньше 1 приводят к увеличению вывода.
 Эта опция на самом деле является сокращенной версией опции --transform.
";ES;fi;;
 23) S=M23;SC;if [[ $cur == enter ]];then R;echo -e "
 Задает размер в пикселях области кадрового буфера,
 которая будет отображаться на этом выходе.
 Эта опция на самом деле является сокращенной версией опции --transform.
";ES;fi;;
 24) S=M24;SC;if [[ $cur == enter ]];then R;echo -e "
 Установите выход как первичный.
 Он будет отсортирован первым в запросах геометрии Xinerama и RANDR.
";ES;fi;;
 25) S=M25;SC;if [[ $cur == enter ]];then R;exit 0;fi;;
 esac;POS;done
